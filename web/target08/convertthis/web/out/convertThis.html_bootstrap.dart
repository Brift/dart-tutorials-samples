import "dart:html" as l;import "dart:async" as aB;import "dart:collection" as yB;import "dart:isolate" as xD;class bD{static const  cD="Chrome";static const  dD="Firefox";static const  eD="Internet Explorer";static const  fD="Safari";final  ND;final  minimumVersion;const bD(this.ND,[this.minimumVersion]);}class gD{const gD();}class hD{final  name;const hD(this.name);}class iD{const iD();}class jD{const jD();}main(){EC=true;VC();WC();}class kD extends IC with q{var BE;static final UC=new l.DocumentFragment.html('''
      <div class="x-converter">
        <span> <content select=".label-one"></content> </span>
        <input type="text" style="text-align:right">
          &lt; &gt;
        <input type="text">
        <span> <content select=".label-two"></content> </span>
      </div>
    ''',treeSanitizer:sC);var CE,DE;var EE; SD(){var FE=createShadowRoot("x-converter");aD("x-converter",new vB({"x-converter":"[is=\"x-converter\"]"}));BE=TD("x-converter");EE=new xC(FE);FE.nodes.add(UC.clone(true));CE=FE.nodes[1].nodes[3];EE.listen(CE.onChange,(h){QD();});EE.listen(CE.onInput,(h){YB=CE.value;});EE.XB(()=>YB,(g){if(CE.value!=g)CE.value=g;},false,false);DE=FE.nodes[1].nodes[5];EE.listen(DE.onChange,(h){RD();});EE.listen(DE.onInput,(h){ZB=DE.value;});EE.XB(()=>ZB,(g){if(DE.value!=g)DE.value=g;},false,false);EE.WB();} UD(){EE.insert();} YD(){EE.remove();EE=CE=DE=null;}var GE=0.5; get ratio{if(lB){mB(this,BB.HB,'ratio');}return GE;}set ratio( g){if(kB(this)){nB(this,BB.HB,'ratio',GE,g);}GE=g;}var IE='0'; get YB{if(lB){mB(this,BB.HB,'thing_one');}return IE;}set YB( g){if(kB(this)){nB(this,BB.HB,'thing_one',IE,g);}IE=g;}var JE='0'; get ZB{if(lB){mB(this,BB.HB,'thing_two');}return JE;}set ZB( g){if(kB(this)){nB(this,BB.HB,'thing_two',JE,g);}JE=g;} QD(){var g=double.parse(YB);var h=g/ratio;ZB=h.toStringAsFixed(2);} RD(){var g=double.parse(ZB);var h=g*ratio;YB=h.toStringAsFixed(2);}} VC(){} WC(){var KE=KD;var LE,ME,NE;var OE=new xC(KE);LE=KE.nodes[1].nodes[1];OE.XB(()=>0.62,(g){if(LE.xtag.ratio!=g)LE.xtag.ratio=g;},false,false);OE.EB(new kD()..host=LE);ME=KE.nodes[1].nodes[3];OE.XB(()=>2.2,(g){if(ME.xtag.ratio!=g)ME.xtag.ratio=g;},false,false);OE.EB(new kD()..host=ME);NE=KE.nodes[1].nodes[5];OE.XB(()=>17.06,(g){if(NE.xtag.ratio!=g)NE.xtag.ratio=g;},false,false);OE.EB(new kD()..host=NE);OE.WB();OE.insert();}class XC implements l.Element{var PE;var QE;var RE={}; get host{if(PE==null)throw new StateError('host element has not been set.');return PE;}set host( g){if(g==null){throw new ArgumentError('host must not be null.');}var h=g.xtag;if(h!=null&&h!=g){throw new ArgumentError('host must not have its xtag property set.');}if(PE!=null){throw new StateError('host can only be set once.');}g.xtag=this;PE=g;}createShadowRoot([ g]){var h=host.createShadowRoot();if(g!=null){RE[g]=h;}return h;} created(){} NC(){} RC(){}get isTemplate=>host.isTemplate;get content=>host.content; getAttribute( g)=>host.getAttribute(g); setAttribute( g, h)=>host.setAttribute(g,h); get childNodes=>host.childNodes; get nodes=>host.nodes; replaceWith( g){host.replaceWith(g);} remove()=>host.remove(); get document=>host.document; get previousNode=>host.previousNode;set text( g){host.text=g;} contains( g)=>host.contains(g); insertBefore( g, h)=>host.insertBefore(g,h); insertAllBefore( g, h)=>host.insertAllBefore(g,h); get attributes=>host.attributes; get children=>host.children; clone( g)=>host.clone(g); get parent=>host.parent; get parentNode=>host.parentNode; get nodeValue=>host.nodeValue; get id=>host.id;set id( g){host.id=g;} createFragment( g,{ validator, treeSanitizer})=>host.createFragment(g,validator:validator,treeSanitizer:treeSanitizer); get tagName=>host.tagName; matches( g)=>host.matches(g); matchesWithAncestors( g)=>host.matchesWithAncestors(g); query( g)=>host.query(g); queryAll( g)=>host.queryAll(g); get firstChild=>host.firstChild; get lastChild=>host.lastChild; get localName=>host.localName; get nodeType=>host.nodeType; LD( g, h,[ i]){host.LD(g,h,i);} MD( g, h,[ i]){host.MD(g,h,i);}get xtag=>host.xtag;set xtag(g){host.xtag=g;} append( g)=>host.append(g); get onChange=>host.onChange; get onInput=>host.onInput;}var zB=false;var YC=o.AC;class GB{final  name; get MC=>(parent==null||parent.name=='')?name:'${parent.MC}.${name}';final  parent;var SE;var children;var TE;var UE;factory GB( g){if(g.startsWith('.')){throw new ArgumentError("name shouldn't start with a '.'");}if(OB==null)OB=<String,GB>{};if(OB.containsKey(g))return OB[g];var h=g.lastIndexOf('.');var i=null;var j;if(h==-1){if(g!='')i=new GB('');j=g;}else{i=new GB(g.substring(0,h));j=g.substring(h+1);}final k=new GB.yD(j,i);OB[g]=k;return k;}GB.yD(this.name,this.parent):children=new Map<String,GB>(){if(parent!=null)parent.children[name]=this;} get fB{if(zB){if(SE!=null)return SE;if(parent!=null)return parent.fB;}return YC;} VD( g)=>(g>=fB); log( h, j,[k]){if(VD(h)){var i=new hB(h,j,MC,k);if(zB){var g=this;while (g!=null){g.VE(i);g=g.parent;}}else{ZC.VE(i);}}} info( g,[h])=>log(o.AC,g,h); wB( g,[h])=>log(o.aC,g,h); VE( g){if(TE!=null){TE.add(g);}}static  get ZC=>new GB('');static var OB;}class o implements Comparable<o>{final  name;final  value;const o(this.name,this.value);static const  AC=const o('INFO',800);static const  aC=const o('WARNING',900); operator==( g)=>g!=null&&value==g.value; operator<( g)=>value<g.value; operator<=( g)=>value<=g.value; operator>( g)=>value>g.value; operator>=( g)=>value>=g.value; compareTo( g)=>value-g.value; get hashCode=>value; toString()=>name;}class hB{final  fB;final  message;final  WD;final  time;final  ZD;static var bC=0;var exception;hB(this.fB,this.message,this.WD,[this.exception]):time=new DateTime.now(),ZD=hB.bC++ ;}const lD=const mD();class mD{const mD();}const nD=const oD();typedef  CB( e);typedef  cC( changes);typedef  DB();typedef  dC();class bB{final oldValue;final newValue;final  changes;bB(this.oldValue,this.newValue,[this.changes]); operator==(g){return g is bB&&oldValue==g.oldValue&&newValue==g.newValue&&changes==g.changes;} get hashCode=>pC(oldValue,newValue,changes); toString(){if(changes!=null)return '#<ChangeNotification to ${newValue}: ${changes}>';return '#<ChangeNotification from ${oldValue} to ${newValue}>';}}class BB{static const HB=1;static const iB=2;static const BC=iB|4;static const CC=iB|8;final  type;final key;final oldValue;final newValue;BB(this.type,this.key,this.oldValue,this.newValue); operator==(g){return g is BB&&type==g.type&&key==g.key&&oldValue==g.oldValue&&newValue==g.newValue;} get hashCode=>qC(type,key,oldValue,newValue); toString(){var g;switch (type){case HB:g='field';break;case iB:g='index';break;case BC:g='insert';break;case CC:g='remove';break;}return '#<ChangeRecord ${g} ${key} from ${oldValue} to ${newValue}>';}} eC(g, i,[ k]){if(g is q){var h=g;return jB(h,(m){i(new bB(h,h,m));});}var j=new cB(g,i,k);if(!j.WE()){return gC;}return j.XE;} jB( g, h){if(g.MB==null)g.MB=new oB();var i=g.MB.add(h);return i.remove;}class q{var MB;var LB;final  hashCode= ++q.fC;static var fC=0;} kB( g)=>g.MB!=null&&g.MB.head!=null; get lB=>KB!=null; mB( g, h,i)=>KB.YE(g,h,i); nB( g, h,k, i, j){if((h&(BB.BC|BB.CC))==0){if(i==j)return;}if(IB==null){IB=[] ;rC(hC);}if(g.LB==null){g.LB=[] ;IB.add(g);}g.LB.add(new BB(h,k,i,j));} gC(){}var KB;var DC=100;var IB;var JB; hC(){var m=0;while (IB!=null||JB!=null){var i=IB;IB=null;var j=JB;JB=null;if(m++ ==DC){iC(i,j);return;}if(i!=null){for(var g in i){var u=g.LB;g.LB=null;for(var h=g.MB.head;h!=null;h=h.next){var k=h.value;try {k(u);}catch (FB,NB){PB(FB,NB,k,'from ${g}');}}}}if(j!=null){j.forEach((TC,xB){xB.ZE();});}}} iC( h, i){var g=[] ;if(h!=null){for(var j in h){var u=j.LB;g.add('${j} ${u}');}}if(i!=null){for(var k in i.values){var m=k.ZE();if(m!=null)g.add('${k} ${m}');}}IB=null;JB=null;var FB='exceeded notifiction limit of ${DC}, possible ' 'circular reference in observer callbacks: ${g.take(10).join(", ")}';lC(FB);}class cB{static var jC=0;final  aE= ++cB.jC;final  bE;final  cE;final  dE;final  eE=new Map();final  fE=[] ;var gE=false;var hE;cB(this.bE,this.cE,this.dE); toString()=>dE!=null?'<observer ${aE}: ${dE}>':'<observer ${aE}>'; WE(){var g=KB;KB=this;try {hE=bE();if(hE is Iterable&&hE is !List&&hE is !q){hE=(hE as Iterable).toList();}}catch (h,i){PB(h,i,bE,'from ${this}');hE=null;}eE.forEach(iE);eE.clear();assert(KB==this);KB=g;jE();return fE.length>0;} kE( g){try {cE(g);}catch (h,i){PB(h,i,cE,'from ${this}');}} jE(){var g=hE;if(g is !q)return;fE.add(jB(g,(h){kE(new bB(g,g,h));}));} YE( j, k,g){var i=eE.putIfAbsent(j,()=>new Map());try {var h=i[g];if(h==null)h=0;i[g]=h|k;}catch (m,u){PB(m,u,g,'hashCode or operator == from ${this}');}} iE( i, j){fE.add(jB(i,(k){if(gE)return;for(var g in k){var h=j[g.key];if(h!=null&&(h&g.type)!=0){gE=true;if(JB==null){JB=new yB.SplayTreeMap();}JB[aE]=this;return;}}}));} XE(){for(var g in fE){g();}gE=false;} ZE(){if(!gE)return null;var g=hE;XE();WE();try {if(g==hE)return null;}catch (i,j){PB(i,j,g,'operator == from ${this}');return null;}var h=new bB(g,hE);kE(h);return h;}}typedef  kC( message);var lC=(g)=>print(g);typedef  mC(error,stackTrace,obj, message);var PB=nC; nC(g,h,i, j){print('web_ui.observe: unhandled error calling ${i} ${j}.\n' 'error:\n${g}\n\nstack trace:\n${h}');}class oD{const oD();}class oC{}class v<AB>{var lE;var mE;var nE;var oE;v.zD( g,this.nE):oE=g{if(nE!=null)nE.pE++ ;} get next=>mE; get value=>oE;set value( g)=>oE=g; qE( g, h){mE=h;lE=g;if(g!=null)g.mE=this;if(h!=null)h.lE=this;return this;} append( g)=>new v<AB>.zD(g,nE).qE(this,mE); remove(){if(nE==null)return;nE.pE-- ;if(lE!=null){lE.mE=mE;}else{nE.rE=mE;}if(mE!=null){mE.lE=lE;}else{nE.sE=lE;}mE=null;lE=null;nE=null;}}class oB<AB> extends yB.IterableBase<AB>{var rE;var sE; get length=>pE;var pE=0;oB(){} get head=>rE; add( h){var g=new v<AB>.zD(h,this);if(sE==null)return rE=sE=g;return sE=g.qE(sE,null);} addLast( g)=>add(g); addAll( g)=>g.forEach(add); get iterator=>new pD<AB>(this);}class pD<AB> implements Iterator<AB>{var tE;var nE;var uE;var vE=-1;pD(this.nE){tE=new List<v>(nE.length);var h=0;var g=nE.head;while (g!=null){tE[h++ ]=g;g=g.next;}} get current=>uE; moveNext(){do{vE++ ;}while(vE<tE.length&&tE[vE].nE!=nE);if(vE<tE.length){uE=tE[vE].value;return true;}else{uE=null;return false;}}}QB(g,h)=>g.hashCode*31+h.hashCode;pC(g,h,i)=>QB(QB(g,h),i);qC(g,h,i,j)=>QB(QB(g,h),QB(i,j)); rC( h()){var g=new xD.ReceivePort();g.receive((i,j){g.close();h();});g.toSendPort().send(null);}var sC=new qD();class qD implements l.NodeTreeSanitizer{ sanitizeTree( g){}} tC(g){if(g is oC)return g.toString();g=g.toString();return vC(g)?g:'#';}const uC=const["http","https","ftp","mailto"]; vC( h){var g=Uri.parse(h).scheme;if(g=='')return true;return uC.contains(g.toLowerCase())||"MAILTO"==g.toUpperCase();}abstract class RB{ WB(){} insert(); remove();}class rD extends RB{final  LC;var wE;final  listener;rD(this.LC,this.listener); insert(){wE=LC.listen(listener);} remove(){wE.cancel();wE=null;}}abstract class wC extends RB{final exp;final  isFinal;final  KC;var gB;wC(this.exp,this.isFinal):KC=pB&&dB!=null?dB():null; insert(){if(isFinal){OC();}else if(gB!=null){throw new StateError('binding already attached');}else{gB=QC();}} remove(){if(!isFinal){gB();gB=null;}} OC(); QC();}class sD extends wC{final  SC;final  PC;sD( g,this.SC,this.PC, h):super(g,h); xE(g){SC(PC?tC(g):g);} OC()=>xE(exp()); QC()=>AD(exp,(g)=>xE(g.newValue),'dom-property-binding',KC);}class tD extends RB{final EB;tD(this.EB); WB(){EB..SD()..created()..PD();} insert(){EB..NC()..UD();} remove(){EB..YD()..RC();}}class xC extends RB{final  XD;final  children=[] ;final  nodes=[] ;xC(this.XD); listen( g, h){children.add(new rD(g,(i){h(i);CD();}));} XB(g,h,i,[j=false]){children.add(new sD(g,h,j,i));} EB( g){children.add(new tD(g));} add( g)=>nodes.add(g); addAll( g)=>nodes.addAll(g); WB(){for(var g=0,h=children.length;g<h;g++ ){children[g].WB();}} insert(){for(var g=0,h=children.length;g<h;g++ ){children[g].insert();}} remove(){for(var g=children.length-1;g>=0;g-- ){children[g].remove();}children.clear();}}var EC=false;var pB=false;var dB=(){try {throw "";}catch (h,g){return g.toString();}};final  SB=new GB('watcher'); yC(g, m,[ j, u]){if(EC)return eC(g,m);if(m==null)return (){};if(TB==null)TB=new oB<UB>();j=j==null?'<unnamed>':j;var i;var h=t.GD;if(g is HC){i=(g as HC).yE;}else if(g is Function){i=g;try {var k=g();if(k is List){h=t.VB;}else if(k is Iterable){h=t.VB;i=()=>g().toList();}else if((k is yB.LinkedHashMap)||(k is yB.SplayTreeMap)){h=t.sB;}else if(k is Map){h=t.rB;}}catch (FB,NB){SB.wB('evaluating ${j} watcher threw error (${FB}, ${NB})');}}else if(g is List){i=()=>g;h=t.VB;}else if(g is Iterable){i=()=>g.toList();h=t.VB;}else if((g is yB.LinkedHashMap)||(g is yB.SplayTreeMap)){i=()=>g;h=t.sB;}else if(g is Map){i=()=>g;h=t.rB;}if(pB&&u==null&&dB!=null){u=dB();}var xB=zC(h,i,m,j,u);var TC=TB.add(xB);return TC.remove;} zC( k, g, h, i, j){switch (k){case t.VB:return new uD(g,h,i,j);case t.sB:return new wD(g,h,i,j);case t.rB:return new vD(g,h,i,j);default:return new UB(g,h,i,j);}} AD(h, i,[ j, k]){var m=yC(h,i,j,k);var g=h;if(g is Function){g=g();}if(g is Iterable&&g is !List){g=g.toList();}i(new bB(null,g));return m;}var TB;class UB{final  debugName;var location;final  zE;static var BD=0;final  yE;final  AF;var BF;UB(this.yE,this.AF,this.debugName,this.location):zE=BD++ {BF=yE();} toString()=>'${debugName} (id: #${zE})'; OD(){var g=CF();if(DF(g)){var h=BF;EF(g);AF(new bB(h,g));return true;}return false;} DF(g)=>BF!=g; EF(g){if(pB){if(location!=null){SB.info('watcher updated: ${this}, defined at:\n${location}');location=null;}else{SB.info('watcher updated: ${this}');}}BF=g;}CF(){try {return yE();}catch (g,h){SB.wB('${this} watcher threw an exception: ${g}, ${h}');}return BF;}}final  FC=10; CD(){if(TB==null)return;var g;var h=0;do{g=false;for(var i in TB){if(i.OD()){g=true;}}}while(g&& ++h<FC);if(h==FC){SB.wB('Possible loop in watchers propagation, stopped dispatch.');}}typedef  GC<DD>();typedef  ED<DD>( value);class HC<DD>{}class uD<DD> extends UB{uD(g, h, i, j):super(g,h,i,j){EF(CF());} DF( g){return qB(BF,g);} EF(g){BF=new List<DD>.from(g);}}class vD<eB,FD> extends UB{vD(g, h, i, j):super(g,h,i,j){EF(CF());} DF( g){var i=BF.keys;if(i.length!=g.keys.length)return true;var j=i.iterator;while (j.moveNext()){var h=j.current;if(!g.containsKey(h))return true;if(BF[h]!=g[h])return true;}return false;} EF(g){BF=new Map<eB,FD>.from(g);}}class wD<eB,FD> extends UB{wD(g, h, i, j):super(g,h,i,j){EF(CF());} DF( g){return qB(g.keys,BF.keys)||qB(g.values,BF.values);} EF(g){BF=new yB.LinkedHashMap.from(g);}} qB( i, j){var h=i.iterator;var g=j.iterator;while (h.moveNext()){if(!g.moveNext())return true;if(h.current!=g.current)return true;}return g.moveNext();}class t{final FF;const t.AE(this.FF);toString()=>'Enum.${FF}';static const VB=const t.AE('LIST');static const rB=const t.AE('HASH_MAP');static const sB=const t.AE('ORDERED_MAP');static const GD=const t.AE('OTHER');}abstract class IC extends XC{var GF;var HF;var IF={};var JF=new vB({}); TD( g)=>JF; aD( h,var g){JF=g;} get host{if(GF==null)throw new StateError('host element has not been set.');return GF;}set host( g){if(g==null){throw new ArgumentError('host must not be null.');}var h=g.xtag;if(h!=null&&h!=g){throw new ArgumentError('host must not have its xtag property set.');}if(GF!=null){throw new StateError('host can only be set once.');}g.xtag=this;GF=g;}createShadowRoot([ g]){var h=KF();if(g!=null){IF[g]=h;}return h;}KF(){if(JC){return host.createShadowRoot();}if(HF==null)HF=[] ;HF.add(new l.DivElement());return HF.last;} created(){} NC(){} RC(){} PD(){if(JC)return;if(HF.length==0){throw new StateError('Distribution algorithm requires at least one shadow' ' root and can only be run once.');}var j=HF;var g=j.removeLast();var u=g;var k=new List.from(nodes);var m=[] ;var FB=[] ;while (true){k=LF(g,k);var h=g.query('shadow');if(h!=null){if(j.length>0){g=j.removeLast();m.add(h);FB.add(g);}else{uB(h,k);break;}}else{break;}}for(int i=0;i<m.length;i++ ){var h=m[i];var g=FB[i];uB(h,g.nodes);}nodes.clear();nodes.addAll(u.nodes);for(var NB in IF.keys){if(IF[NB]==u){IF[NB]=this;break;}}} LF( u, j){for(var g in u.queryAll('content')){if(!ID(g))continue;var h=g.attributes['select'];if(h==null||h=='')h='*';var i=[] ;var k=[] ;for(var m in j){(HD(m,h)?i:k).add(m);}if(i.length==0){i=g.nodes;}uB(g,i);j=k;}return j;}static  HD( g, h){if(g is !l.Element)return h=='*';return (g as l.Element).matches(h);}static  tB( g)=>g.tagName=='CONTENT'||g.tagName=='SHADOW';static  ID( g){assert(tB(g));for(g=g.parent;g!=null;g=g.parent){if(tB(g))return false;}return true;}static  uB( g, h){assert(tB(g));g.parent.insertAllBefore(h,g);g.remove();}}class vB{final  MF;vB(this.MF); operator[]( g)=>MF[g];}var JD=false; get JC=>JD&&l.ShadowRoot.supported;var KD=l.document.body;
//# sourceMappingURL=convertThis.html_bootstrap.dart.map
//@ sourceMappingURL=convertThis.html_bootstrap.dart.map
