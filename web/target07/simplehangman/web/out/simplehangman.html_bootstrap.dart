import "dart:html" as EB;import "dart:collection" as uB;import "dart:async" as PC;import "dart:isolate" as IE;class nD{static const  oD="Chrome";static const  pD="Firefox";static const  qD="Internet Explorer";static const  rD="Safari";final  hD;final  minimumVersion;const nD(this.hD,[this.minimumVersion]);}class sD{const sD();}class tD{final  name;const tD(this.name);}class uD{const uD();}class vD{const vD();}var QC='pumpernickel';var vB=QC.split("");var wB=VC(QC.replaceAll(new RegExp('.'),'-').split(""));var kB=VC(new List());final NB=new u();var xB=''; get ZB{if(q){AB(NB,k.o,'guessedletter');}return xB;}set ZB( g){if(IB(NB)){m(NB,k.o,'guessedletter',xB,g);}xB=g;}var yB=false; get RC{if(q){AB(NB,k.o,'dead');}return yB;}set RC( g){if(IB(NB)){m(NB,k.o,'dead',yB,g);}yB=g;}var zB=false; get SC{if(q){AB(NB,k.o,'won');}return zB;}set SC( g){if(IB(NB)){m(NB,k.o,'won',zB,g);}zB=g;} nC(){} oC(){const  g=7;if(vB.contains(ZB)){pC();if(!wB.contains('-')){SC=true;}}else{kB.add(ZB);if(kB.length==g){RC=true;}}ZB='';} pC(){for(int g=0;g<vB.length;g++ ){if(vB[g]==ZB){wB[g]=ZB;}}} qC(){var QE=gD;final RE=new EB.InputElement(),SE=new EB.Element.html('<p>\n              <template></template>\n            </p>',treeSanitizer:DC),TE=new EB.Element.html('<p id="wrong">\n              <template></template>\n            </p>',treeSanitizer:DC);var UE,VE,WE,XE;var YE=new ZC(QE);UE=QE.nodes[3].nodes[1];YE.loop(UE,()=>wB,(g,h,YE){var l=g[h];var ZE=YE.gC(()=>l,false);YE.addAll([new EB.Text(' '),ZE,new EB.Text(' ')]);});WE=QE.nodes[5].nodes[1];YE.rB(WE,()=>!RC&&!SC,(YE){var aE,bE,cE,dE,eE;aE=RE.clone(true);YE.listen(aE.onInput,(i){ZB=aE.value;});YE.listen(aE.onKeyUp,(i){i=new EB.KeyEvent(i);oC();});YE.lD(()=>ZB,(j){if(aE.value!=j)aE.value=j;},false,false);cE=SE.clone(true);bE=cE.nodes[1];YE.rB(bE,()=>kB.length!=0,(YE){YE.add(new EB.Text(' Sorry! The word contains no: '));});eE=TE.clone(true);dE=eE.nodes[1];YE.loop(dE,()=>kB,(g,h,YE){var BB=g[h];var fE=YE.gC(()=>BB,false);YE.addAll([new EB.Text(' '),fE,new EB.Text(' ')]);});YE.addAll([new EB.Text('\n            Guess a letter...\n            '),aE,new EB.Text('\n            '),cE,new EB.Text('\n            '),eE,new EB.Text('\n          ')]);});XE=QE.nodes[5].nodes[3];YE.rB(XE,()=>RC,(YE){YE.add(new EB.Text(' You\'re dead! '));});VE=QE.nodes[5].nodes[5];YE.rB(VE,()=>SC,(YE){YE.add(new EB.Text(' You Win! '));});YE.iB();YE.insert();}main(){bC=true;nC();qC();}var TC=false;var rC=t.UC;class QB{final  name; get iC=>(parent==null||parent.name=='')?name:'${parent.iC}.${name}';final  parent;var gE;var children;var hE;var iE;factory QB( g){if(g.startsWith('.')){throw new ArgumentError("name shouldn't start with a '.'");}if(aB==null)aB=<String,QB>{};if(aB.containsKey(g))return aB[g];var h=g.lastIndexOf('.');var i=null;var j;if(h==-1){if(g!='')i=new QB('');j=g;}else{i=new QB(g.substring(0,h));j=g.substring(h+1);}final l=new QB.JE(j,i);aB[g]=l;return l;}QB.JE(this.name,this.parent):children=new Map<String,QB>(){if(parent!=null)parent.children[name]=this;} get tB{if(TC){if(gE!=null)return gE;if(parent!=null)return parent.tB;}return rC;} jD( g)=>(g>=tB); log( h, j,[l]){if(jD(h)){var i=new AC(h,j,iC,l);if(TC){var g=this;while (g!=null){g.jE(i);g=g.parent;}}else{sC.jE(i);}}} info( g,[h])=>log(t.UC,g,h); MC( g,[h])=>log(t.tC,g,h); jE( g){if(hE!=null){hE.add(g);}}static  get sC=>new QB('');static var aB;}class t implements Comparable<t>{final  name;final  value;const t(this.name,this.value);static const  UC=const t('INFO',800);static const  tC=const t('WARNING',900); operator==( g)=>g!=null&&value==g.value; operator<( g)=>value<g.value; operator<=( g)=>value<=g.value; operator>( g)=>value>g.value; operator>=( g)=>value>=g.value; compareTo( g)=>value-g.value; get hashCode=>value; toString()=>name;}class AC{final  tB;final  message;final  kD;final  time;final  mD;static var uC=0;var exception;AC(this.tB,this.message,this.kD,[this.exception]):time=new DateTime.now(),mD=AC.uC++ ;}class vC<PB> extends QD with u implements List<PB>{final  kE;vC([ g]):kE=g!=null?new List<PB>(g):<PB>[] ;factory vC.KE( g)=>new vC<PB>()..addAll(g); get length{if(q)AB(this,k.o,'length');return kE.length;}set length( h){var i=kE.length;if(i==h)return;if(IB(this)){if(h<i){for(int g=i-1;g>=h;g-- ){m(this,k.SB,g,kE[g],null);}m(this,k.o,'length',i,h);}else{m(this,k.o,'length',i,h);for(int g=i;g<h;g++ ){m(this,k.RB,g,null,null);}}}kE.length=h;} operator[]( g){if(q)AB(this,k.HB,g);return kE[g];}operator[]=( g, h){var i=kE[g];if(IB(this)){m(this,k.HB,g,i,h);}kE[g]=h;} sublist( g,[ h])=>new vC<PB>.KE(super.sublist(g,h)); add( h){var g=kE.length;if(IB(this)){m(this,k.o,'length',g,g+1);m(this,k.RB,g,null,h);}kE.add(h);} expand( g(E)){throw new UnimplementedError();return null;} toString(){if(q){for(int g=0;g<length;g++ ){AB(this,k.HB,g);}}return kE.toString();}}typedef  bB<CB,v>();class VB<CB,v> extends u implements Map<CB,v>{final  lE;var mE;var nE;VB({ createMap}):lE=createMap!=null?createMap():new Map<CB,v>(){mE=new wC<CB,v>(this);nE=new xC<CB,v>(this);}factory VB.LE( h,{ createMap}){var g=new VB(createMap:createMap);h.forEach((i,j){g[i]=j;});return g;} get keys=>mE; get values=>nE; get length{if(q)AB(this,k.o,'length');return lE.length;} get isEmpty=>length==0; get isNotEmpty=>length!=0; oE( g)=>AB(this,k.HB,g); pE(){AB(this,k.o,'length');lE.keys.forEach(oE);} containsKey( g){if(q)oE(g);return lE.containsKey(g);} operator[]( g){if(q)oE(g);return lE[g];} operator[]=( g, h){var j=lE.length;var i=lE[g];lE[g]=h;if(IB(this)){if(j!=lE.length){m(this,k.o,'length',j,lE.length);m(this,k.RB,g,i,h);}else if(i!=h){m(this,k.HB,g,i,h);}}} putIfAbsent( g, j()){if(q)oE(g);var h=lE.length;var i=lE.putIfAbsent(g,j);if(IB(this)&&h!=lE.length){m(this,k.o,'length',h,lE.length);m(this,k.RB,g,null,i);}return i;} remove( g){if(q)oE(g);var h=lE.length;var i=lE.remove(g);if(IB(this)&&h!=lE.length){m(this,k.SB,g,i,null);m(this,k.o,'length',h,lE.length);}return i;} addAll( g)=>g.forEach((h,i){this[h]=i;}); clear(){var g=lE.length;if(IB(this)&&g>0){lE.forEach((h,i){m(this,k.SB,h,i,null);});m(this,k.o,'length',g,0);}lE.clear();} forEach( g( key, value)){if(q)pE();lE.forEach(g);} toString()=>uB.Maps.mapToString(this);}class wC<CB,v> extends uB.IterableBase<CB>{final  lE;wC(this.lE); get iterator=>new wD<CB,v>(lE);}class wD<CB,v> implements Iterator<CB>{final  lE;final  mE;var qE=false;wD( g):lE=g,mE=g.lE.keys.iterator; moveNext(){if(q)AB(lE,k.o,'length');return qE=mE.moveNext();} get current{var g=mE.current;if(q&&qE)lE.oE(g);return g;}}class xC<CB,v> extends uB.IterableBase<v>{final  lE;xC(this.lE); get iterator=>new xD<CB,v>(lE);}class xD<CB,v> implements Iterator<v>{final  lE;final  mE;final  nE;var qE;xD( g):lE=g,mE=g.lE.keys.iterator,nE=g.lE.values.iterator; moveNext(){if(q)AB(lE,k.o,'length');var h=mE.moveNext();var g=nE.moveNext();if(h!=g){throw new StateError('keys and values should be the same length');}return qE=g;} get current{if(q&&qE)lE.oE(mE.current);return nE.current;}}typedef  LB( e);typedef  yC( changes);typedef  MB();typedef  zC();class lB{final oldValue;final newValue;final  changes;lB(this.oldValue,this.newValue,[this.changes]); operator==(g){return g is lB&&oldValue==g.oldValue&&newValue==g.newValue&&changes==g.changes;} get hashCode=>MD(oldValue,newValue,changes); toString(){if(changes!=null)return '#<ChangeNotification to ${newValue}: ${changes}>';return '#<ChangeNotification from ${oldValue} to ${newValue}>';}}class k{static const o=1;static const HB=2;static const RB=HB|4;static const SB=HB|8;final  type;final key;final oldValue;final newValue;k(this.type,this.key,this.oldValue,this.newValue); operator==(g){return g is k&&type==g.type&&key==g.key&&oldValue==g.oldValue&&newValue==g.newValue;} get hashCode=>ND(type,key,oldValue,newValue); toString(){var g;switch (type){case o:g='field';break;case HB:g='index';break;case RB:g='insert';break;case SB:g='remove';break;}return '#<ChangeRecord ${g} ${key} from ${oldValue} to ${newValue}>';}} AD(g, i,[ l]){if(g is u){var h=g;return BC(h,(BB){i(new lB(h,h,BB));});}var j=new mB(g,i,l);if(!j.rE()){return CD;}return j.sE;} BC( g, h){if(g.YB==null)g.YB=new CC();var i=g.YB.add(h);return i.remove;}VC(g){if(g is Map){var h=null;if(g is uB.SplayTreeMap){h=()=>new uB.SplayTreeMap();}else if(g is uB.LinkedHashMap){h=()=>new uB.LinkedHashMap();}return new VB.LE(g,createMap:h);}if(g is Set)return new XC.ME(g);if(g is Iterable)return new vC.KE(g);return g;}class u{var YB;var XB;final  hashCode= ++u.BD;static var BD=0;} IB( g)=>g.YB!=null&&g.YB.head!=null; get q=>WB!=null; AB( g, h,i)=>WB.tE(g,h,i); m( g, h,l, i, j){if((h&(k.RB|k.SB))==0){if(i==j)return;}if(TB==null){TB=[] ;OD(DD);}if(g.XB==null){g.XB=[] ;TB.add(g);}g.XB.add(new k(h,l,i,j));} CD(){}var WB;var WC=100;var TB;var UB; DD(){var BB=0;while (TB!=null||UB!=null){var i=TB;TB=null;var j=UB;UB=null;if(BB++ ==WC){ED(i,j);return;}if(i!=null){for(var g in i){var OB=g.XB;g.XB=null;for(var h=g.YB.head;h!=null;h=h.next){var l=h.value;try {l(OB);}catch (jB,NC){cB(jB,NC,l,'from ${g}');}}}}if(j!=null){j.forEach((mC,OC){OC.uE();});}}} ED( h, i){var g=[] ;if(h!=null){for(var j in h){var OB=j.XB;g.add('${j} ${OB}');}}if(i!=null){for(var l in i.values){var BB=l.uE();if(BB!=null)g.add('${l} ${BB}');}}TB=null;UB=null;var jB='exceeded notifiction limit of ${WC}, possible ' 'circular reference in observer callbacks: ${g.take(10).join(", ")}';HD(jB);}class mB{static var FD=0;final  vE= ++mB.FD;final  wE;final  xE;final  yE;final  zE=new Map();final  AF=[] ;var BF=false;var CF;mB(this.wE,this.xE,this.yE); toString()=>yE!=null?'<observer ${vE}: ${yE}>':'<observer ${vE}>'; rE(){var g=WB;WB=this;try {CF=wE();if(CF is Iterable&&CF is !List&&CF is !u){CF=(CF as Iterable).toList();}}catch (h,i){cB(h,i,wE,'from ${this}');CF=null;}zE.forEach(DF);zE.clear();assert(WB==this);WB=g;EF();return AF.length>0;} FF( g){try {xE(g);}catch (h,i){cB(h,i,xE,'from ${this}');}} EF(){var g=CF;if(g is !u)return;AF.add(BC(g,(h){FF(new lB(g,g,h));}));} tE( j, l,g){var i=zE.putIfAbsent(j,()=>new Map());try {var h=i[g];if(h==null)h=0;i[g]=h|l;}catch (BB,OB){cB(BB,OB,g,'hashCode or operator == from ${this}');}} DF( i, j){AF.add(BC(i,(l){if(BF)return;for(var g in l){var h=j[g.key];if(h!=null&&(h&g.type)!=0){BF=true;if(UB==null){UB=new uB.SplayTreeMap();}UB[vE]=this;return;}}}));} sE(){for(var g in AF){g();}BF=false;} uE(){if(!BF)return null;var g=CF;sE();rE();try {if(g==CF)return null;}catch (i,j){cB(i,j,g,'operator == from ${this}');return null;}var h=new lB(g,CF);FF(h);return h;}}typedef  GD( message);var HD=(g)=>print(g);typedef  ID(error,stackTrace,obj, message);var cB=JD; JD(g,h,i, j){print('web_ui.observe: unhandled error calling ${i} ${j}.\n' 'error:\n${g}\n\nstack trace:\n${h}');}class XC<JB> extends PD with u implements Set<JB>{final  GF;final  HF;XC({ createMap}):GF=createMap!=null?createMap():new Map<JB,Object>(),HF=createMap;factory XC.ME( g,{ createMap}){return new XC<JB>(createMap:createMap)..addAll(g);} contains( g){if(q)AB(this,k.HB,g);return GF.containsKey(g);} add( g){var h=GF.length;GF[g]=const Object();if(h!=GF.length){m(this,k.o,'length',h,GF.length);m(this,k.RB,g,null,g);}} remove( g){if(q)AB(this,k.HB,g);var h=GF.length;GF.remove(g);if(h!=GF.length){if(IB(this)){m(this,k.SB,g,g,null);m(this,k.o,'length',h,GF.length);}return true;}return false;} clear(){if(IB(this)){for(var g in GF.keys){m(this,k.SB,g,g,null);}m(this,k.o,'length',GF.length,0);}GF.clear();} get length{if(q)AB(this,k.o,'length');return GF.length;} get isEmpty=>length==0; get iterator=>new yD<JB>(this); addAll( g)=>g.forEach(add); toString(){if(q){for(JB g in GF.keys){AB(this,k.HB,g);}}return GF.keys.toSet().toString();}}class yD<JB> implements Iterator<JB>{final  IF;final  JF;var KF=false;yD( g):IF=g,JF=g.GF.keys.iterator; moveNext(){IF.length;return KF=JF.moveNext();} get current{var g=JF.current;if(q&&KF)AB(IF,k.HB,g);return g;}}class KD{}class LD{}class FB<GB>{var LF;var MF;var NF;var OF;FB.NE( g,this.NF):OF=g{if(NF!=null)NF.PF++ ;} get next=>MF; get value=>OF;set value( g)=>OF=g; QF( g, h){MF=h;LF=g;if(g!=null)g.MF=this;if(h!=null)h.LF=this;return this;} append( g)=>new FB<GB>.NE(g,NF).QF(this,MF); remove(){if(NF==null)return;NF.PF-- ;if(LF!=null){LF.MF=MF;}else{NF.RF=MF;}if(MF!=null){MF.LF=LF;}else{NF.SF=LF;}MF=null;LF=null;NF=null;}}class CC<GB> extends uB.IterableBase<GB>{var RF;var SF; get length=>PF;var PF=0;CC(){} get head=>RF; add( h){var g=new FB<GB>.NE(h,this);if(SF==null)return RF=SF=g;return SF=g.QF(SF,null);} addLast( g)=>add(g); addAll( g)=>g.forEach(add); get iterator=>new zD<GB>(this);}class zD<GB> implements Iterator<GB>{var TF;var NF;var UF;var VF=-1;zD(this.NF){TF=new List<FB>(NF.length);var h=0;var g=NF.head;while (g!=null){TF[h++ ]=g;g=g.next;}} get current=>UF; moveNext(){do{VF++ ;}while(VF<TF.length&&TF[VF].NF!=NF);if(VF<TF.length){UF=TF[VF].value;return true;}else{UF=null;return false;}}}dB(g,h)=>g.hashCode*31+h.hashCode;MD(g,h,i)=>dB(dB(g,h),i);ND(g,h,i,j)=>dB(dB(g,h),dB(i,j)); OD( h()){var g=new IE.ReceivePort();g.receive((i,j){g.close();h();});g.toSendPort().send(null);}abstract class PD extends uB.IterableBase<dynamic>{}abstract class QD extends uB.ListMixin<dynamic>{}var DC=new AE();class AE implements EB.NodeTreeSanitizer{ sanitizeTree( g){}} RD(h, g,[ i]){if(h is EB.Node){g.replaceWith(h);return h;}var j=h is KD;if(i==null){i=h.toString();}if(!j&&g is EB.Text){g.text=i;}else{var l=g;g=!j?new EB.Text(i):new EB.Element.html(i,treeSanitizer:DC);l.replaceWith(g);}return g;} SD(g){if(g is LD)return g.toString();g=g.toString();return UD(g)?g:'#';}const TD=const["http","https","ftp","mailto"]; UD( h){var g=Uri.parse(h).scheme;if(g=='')return true;return TD.contains(g.toLowerCase())||"MAILTO"==g.toUpperCase();}abstract class nB{ iB(){} insert(); remove();}class BE extends nB{final  hC;var WF;final  listener;BE(this.hC,this.listener); insert(){WF=hC.listen(listener);} remove(){WF.cancel();WF=null;}}abstract class YC extends nB{final exp;final  isFinal;final  IC;var KB;YC(this.exp,this.isFinal):IC=EC&&oB!=null?oB():null; insert(){if(isFinal){JC();}else if(KB!=null){throw new StateError('binding already attached');}else{KB=LC();}} remove(){if(!isFinal){KB();KB=null;}} JC(); LC();}class CE extends YC{final  action;CE(g,this.action, h):super(g,h); JC()=>action(new lB(null,exp())); LC()=>pB(exp,action,'generic-binding',IC);}class DE extends YC{final  lC;final  jC;DE( g,this.lC,this.jC, h):super(g,h); XF(g){lC(jC?SD(g):g);} JC()=>XF(exp()); LC()=>pB(exp,(g)=>XF(g.newValue),'dom-property-binding',IC);}class ZC extends nB{final  KC;final  children=[] ;final  nodes=[] ;ZC(this.KC); listen( g, h){children.add(new BE(g,(i){h(i);bD();}));} gC( h,i){var g=new EB.Text('');children.add(new CE(()=>'${h()}',(j){g=RD(h(),g,j.newValue);},i));return g;} lD(g,h,i,[j=false]){children.add(new DE(g,h,j,i));} rB( g,h,i){children.add(new WD(g,h,i));} loop( g,h,i){children.add(new EE(g,h,i));} add( g)=>nodes.add(g); addAll( g)=>nodes.addAll(g); iB(){for(var g=0,h=children.length;g<h;g++ ){children[g].iB();}} insert(){for(var g=0,h=children.length;g<h;g++ ){children[g].insert();}} remove(){for(var g=children.length-1;g>=0;g-- ){children[g].remove();}children.clear();}}abstract class aC extends ZC{final exp;var KB;aC( g,this.exp):super(g); iB(){} insert(){super.iB();if(nodes.length>0){var h=KC.parentNode;var i=KC.nextNode;for(var g=0,j=nodes.length;g<j;g++ ){h.insertBefore(nodes[g],i);}}super.insert();} remove(){super.remove();for(var g=nodes.length-1;g>=0;g-- ){nodes[g].remove();}nodes.clear();}}typedef  VD( template);class WD extends aC{var sB=false;final  fC;WD( g,h,this.fC):super(g,h); insert(){KB=pB(exp,(g){if(!sB&&g.newValue){fC(this);super.insert();sB=true;}else if(sB&&!g.newValue){super.remove();sB=false;}},'conditional-binding');} remove(){super.remove();KB();KB=null;}}typedef  XD( list, index, template);class EE extends aC{final  kC;EE( g,h,this.kC):super(g,h); insert(){KB=pB(exp,(i){super.remove();var h=i.newValue;for(int g=0;g<h.length;g++ ){kC(h,g,this);}super.insert();},'loop-binding');} remove(){super.remove();KB();KB=null;}}var bC=false;var EC=false;var oB=(){try {throw "";}catch (h,g){return g.toString();}};final  eB=new QB('watcher'); YD(g, BB,[ j, OB]){if(bC)return AD(g,BB);if(BB==null)return (){};if(fB==null)fB=new CC<gB>();j=j==null?'<unnamed>':j;var i;var h=DB.fD;if(g is eC){i=(g as eC).YF;}else if(g is Function){i=g;try {var l=g();if(l is List){h=DB.hB;}else if(l is Iterable){h=DB.hB;i=()=>g().toList();}else if((l is uB.LinkedHashMap)||(l is uB.SplayTreeMap)){h=DB.HC;}else if(l is Map){h=DB.GC;}}catch (jB,NC){eB.MC('evaluating ${j} watcher threw error (${jB}, ${NC})');}}else if(g is List){i=()=>g;h=DB.hB;}else if(g is Iterable){i=()=>g.toList();h=DB.hB;}else if((g is uB.LinkedHashMap)||(g is uB.SplayTreeMap)){i=()=>g;h=DB.HC;}else if(g is Map){i=()=>g;h=DB.GC;}if(EC&&OB==null&&oB!=null){OB=oB();}var OC=ZD(h,i,BB,j,OB);var mC=fB.add(OC);return mC.remove;} ZD( l, g, h, i, j){switch (l){case DB.hB:return new FE(g,h,i,j);case DB.HC:return new HE(g,h,i,j);case DB.GC:return new GE(g,h,i,j);default:return new gB(g,h,i,j);}} pB(h, i,[ j, l]){var BB=YD(h,i,j,l);var g=h;if(g is Function){g=g();}if(g is Iterable&&g is !List){g=g.toList();}i(new lB(null,g));return BB;}var fB;class gB{final  debugName;var location;final  ZF;static var aD=0;final  YF;final  aF;var bF;gB(this.YF,this.aF,this.debugName,this.location):ZF=aD++ {bF=YF();} toString()=>'${debugName} (id: #${ZF})'; iD(){var g=cF();if(dF(g)){var h=bF;eF(g);aF(new lB(h,g));return true;}return false;} dF(g)=>bF!=g; eF(g){if(EC){if(location!=null){eB.info('watcher updated: ${this}, defined at:\n${location}');location=null;}else{eB.info('watcher updated: ${this}');}}bF=g;}cF(){try {return YF();}catch (g,h){eB.MC('${this} watcher threw an exception: ${g}, ${h}');}return bF;}}final  cC=10; bD(){if(fB==null)return;var g;var h=0;do{g=false;for(var i in fB){if(i.iD()){g=true;}}}while(g&& ++h<cC);if(h==cC){eB.MC('Possible loop in watchers propagation, stopped dispatch.');}}typedef  dC<cD>();typedef  dD<cD>( value);class eC<cD>{}class FE<cD> extends gB{FE(g, h, i, j):super(g,h,i,j){eF(cF());} dF( g){return FC(bF,g);} eF(g){bF=new List<cD>.from(g);}}class GE<qB,eD> extends gB{GE(g, h, i, j):super(g,h,i,j){eF(cF());} dF( g){var i=bF.keys;if(i.length!=g.keys.length)return true;var j=i.iterator;while (j.moveNext()){var h=j.current;if(!g.containsKey(h))return true;if(bF[h]!=g[h])return true;}return false;} eF(g){bF=new Map<qB,eD>.from(g);}}class HE<qB,eD> extends gB{HE(g, h, i, j):super(g,h,i,j){eF(cF());} dF( g){return FC(g.keys,bF.keys)||FC(g.values,bF.values);} eF(g){bF=new uB.LinkedHashMap.from(g);}} FC( i, j){var h=i.iterator;var g=j.iterator;while (h.moveNext()){if(!g.moveNext())return true;if(h.current!=g.current)return true;}return g.moveNext();}class DB{final fF;const DB.OE(this.fF);toString()=>'Enum.${fF}';static const hB=const DB.OE('LIST');static const GC=const DB.OE('HASH_MAP');static const HC=const DB.OE('ORDERED_MAP');static const fD=const DB.OE('OTHER');}var gD=EB.document.body;
//# sourceMappingURL=simplehangman.html_bootstrap.dart.map
//@ sourceMappingURL=simplehangman.html_bootstrap.dart.map
