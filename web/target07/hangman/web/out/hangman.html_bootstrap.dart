import "dart:html" as CB;import "dart:collection" as xB;import "dart:async" as UC;import "dart:isolate" as QE;class uD{static const  vD="Chrome";static const  wD="Firefox";static const  xD="Internet Explorer";static const  yD="Safari";final  oD;final  minimumVersion;const uD(this.oD,[this.minimumVersion]);}class zD{const zD();}class AE{final  name;const AE(this.name);}class BE{const BE();}class CE{const CE();}var VC='ambidextrous';var yB=VC.split("");var zB=FC(VC.replaceAll(new RegExp('.'),'-').split(""));var RB=FC(new List());var oB;final OB=new v();var AC=''; get cB{if(q){BB(OB,k.o,'guessedletter');}return AC;}set cB( g){if(HB(OB)){m(OB,k.o,'guessedletter',AC,g);}AC=g;}var BC=false; get WC{if(q){BB(OB,k.o,'dead');}return BC;}set WC( g){if(HB(OB)){m(OB,k.o,'dead',BC,g);}BC=g;}var CC=false; get XC{if(q){BB(OB,k.o,'won');}return CC;}set XC( g){if(HB(OB)){m(OB,k.o,'won',CC,g);}CC=g;} rC(){vC();} sC(){const  g=7;if(yB.contains(cB)){tC();if(!zB.contains('-')){XC=true;}}else{uC();RB.add(cB);if(RB.length==g){WC=true;}}cB='';} tC(){for(int g=0;g<yB.length;g++ ){if(yB[g]==cB){zB[g]=cB;}}} uC(){var g=[[1,4,'0'],[2,3,'\/'],[2,4,'\|'],[2,5,'\\'],[3,4,'\|'],[4,3,'\/'],[4,5,'\\']];var h=g[RB.length][0];var i=g[RB.length][1];oB[h][i]=g[RB.length][2];} vC(){var h=['+---+  ','\|      ','\|      ','\|      ','\|      '];oB=new List(h.length);for(int g=0;g<h.length;g++ ){var i=h[g].split("");oB[g]=FC(i);}} wC(){var YE=nD;final ZE=new CB.TableRowElement(),aE=new CB.Element.tag('td'),bE=new CB.InputElement(),cE=new CB.Element.html('<p>\n            <template></template>\n          </p>',treeSanitizer:HC),dE=new CB.Element.html('<p id="wrong">\n            <template></template>\n          </p>',treeSanitizer:HC);var eE,fE,gE,hE,iE;var jE=new IC(YE);hE=YE.nodes[3].nodes[1].nodes[1];jE.oC(hE,()=>oB,(g,h,jE){var l=g[h];var kE;kE=ZE.clone(true);jE.oC(kE,()=>l,(g,h,jE){var t=g[h];var lE;lE=aE.clone(true);var mE=jE.NC(()=>t,false);lE.nodes.add(mE);jE.addAll([new CB.Text('\n            '),lE,new CB.Text('\n          ')]);});jE.addAll([new CB.Text('\n          '),kE,new CB.Text('\n        ')]);});iE=YE.nodes[5].nodes[1];jE.loop(iE,()=>zB,(g,h,jE){var GB=g[h];var nE=jE.NC(()=>GB,false);jE.addAll([new CB.Text(' '),nE,new CB.Text(' ')]);});eE=YE.nodes[7].nodes[1];jE.uB(eE,()=>!WC&&!XC,(jE){var oE,pE,qE,rE,sE;qE=bE.clone(true);jE.listen(qE.onInput,(i){cB=qE.value;});jE.listen(qE.onKeyUp,(i){i=new CB.KeyEvent(i);sC();});jE.sD(()=>cB,(j){if(qE.value!=j)qE.value=j;},false,false);sE=cE.clone(true);rE=sE.nodes[1];jE.uB(rE,()=>RB.length!=0,(jE){jE.add(new CB.Text(' Sorry! The word contains no: '));});pE=dE.clone(true);oE=pE.nodes[1];jE.loop(oE,()=>RB,(g,h,jE){var XB=g[h];var tE=jE.NC(()=>XB,false);jE.addAll([new CB.Text(' '),tE,new CB.Text(' ')]);});jE.addAll([new CB.Text('\n          Guess a letter...\n          '),qE,new CB.Text('\n          '),sE,new CB.Text('\n          '),pE,new CB.Text('\n        ')]);});fE=YE.nodes[7].nodes[3];jE.uB(fE,()=>WC,(jE){jE.add(new CB.Text(' You\'re dead! '));});gE=YE.nodes[7].nodes[5];jE.uB(gE,()=>XC,(jE){jE.add(new CB.Text(' You Win! '));});jE.WB();jE.insert();}main(){gC=true;rC();wC();}var YC=false;var xC=u.ZC;class SB{final  name; get mC=>(parent==null||parent.name=='')?name:'${parent.mC}.${name}';final  parent;var uE;var children;var vE;var wE;factory SB( g){if(g.startsWith('.')){throw new ArgumentError("name shouldn't start with a '.'");}if(dB==null)dB=<String,SB>{};if(dB.containsKey(g))return dB[g];var h=g.lastIndexOf('.');var i=null;var j;if(h==-1){if(g!='')i=new SB('');j=g;}else{i=new SB(g.substring(0,h));j=g.substring(h+1);}final l=new SB.RE(j,i);dB[g]=l;return l;}SB.RE(this.name,this.parent):children=new Map<String,SB>(){if(parent!=null)parent.children[name]=this;} get wB{if(YC){if(uE!=null)return uE;if(parent!=null)return parent.wB;}return xC;} qD( g)=>(g>=wB); log( h, j,[l]){if(qD(h)){var i=new DC(h,j,mC,l);if(YC){var g=this;while (g!=null){g.xE(i);g=g.parent;}}else{yC.xE(i);}}} info( g,[h])=>log(u.ZC,g,h); RC( g,[h])=>log(u.zC,g,h); xE( g){if(vE!=null){vE.add(g);}}static  get yC=>new SB('');static var dB;}class u implements Comparable<u>{final  name;final  value;const u(this.name,this.value);static const  ZC=const u('INFO',800);static const  zC=const u('WARNING',900); operator==( g)=>g!=null&&value==g.value; operator<( g)=>value<g.value; operator<=( g)=>value<=g.value; operator>( g)=>value>g.value; operator>=( g)=>value>=g.value; compareTo( g)=>value-g.value; get hashCode=>value; toString()=>name;}class DC{final  wB;final  message;final  rD;final  time;final  tD;static var AD=0;var exception;DC(this.wB,this.message,this.rD,[this.exception]):time=new DateTime.now(),tD=DC.AD++ ;}class BD<PB> extends YD with v implements List<PB>{final  yE;BD([ g]):yE=g!=null?new List<PB>(g):<PB>[] ;factory BD.SE( g)=>new BD<PB>()..addAll(g); get length{if(q)BB(this,k.o,'length');return yE.length;}set length( h){var i=yE.length;if(i==h)return;if(HB(this)){if(h<i){for(int g=i-1;g>=h;g-- ){m(this,k.QB,g,yE[g],null);}m(this,k.o,'length',i,h);}else{m(this,k.o,'length',i,h);for(int g=i;g<h;g++ ){m(this,k.TB,g,null,null);}}}yE.length=h;} operator[]( g){if(q)BB(this,k.KB,g);return yE[g];}operator[]=( g, h){var i=yE[g];if(HB(this)){m(this,k.KB,g,i,h);}yE[g]=h;} sublist( g,[ h])=>new BD<PB>.SE(super.sublist(g,h)); add( h){var g=yE.length;if(HB(this)){m(this,k.o,'length',g,g+1);m(this,k.TB,g,null,h);}yE.add(h);} removeRange( h, g){if(g==0)return;cC.WD(this,h,g);if(HB(this)){for(int i=h;i<g;i++ ){m(this,k.QB,i,this[i],null);}}cC.VD(this,h+g,this,h,this.length-g-h);this.length=this.length-g;} expand( g(E)){throw new UnimplementedError();return null;} toString(){if(q){for(int g=0;g<length;g++ ){BB(this,k.KB,g);}}return yE.toString();}}typedef  eB<EB,AB>();class YB<EB,AB> extends v implements Map<EB,AB>{final  zE;var AF;var BF;YB({ createMap}):zE=createMap!=null?createMap():new Map<EB,AB>(){AF=new CD<EB,AB>(this);BF=new DD<EB,AB>(this);}factory YB.TE( h,{ createMap}){var g=new YB(createMap:createMap);h.forEach((i,j){g[i]=j;});return g;} get keys=>AF; get values=>BF; get length{if(q)BB(this,k.o,'length');return zE.length;} get isEmpty=>length==0; get isNotEmpty=>length!=0; CF( g)=>BB(this,k.KB,g); DF(){BB(this,k.o,'length');zE.keys.forEach(CF);} containsKey( g){if(q)CF(g);return zE.containsKey(g);} operator[]( g){if(q)CF(g);return zE[g];} operator[]=( g, h){var j=zE.length;var i=zE[g];zE[g]=h;if(HB(this)){if(j!=zE.length){m(this,k.o,'length',j,zE.length);m(this,k.TB,g,i,h);}else if(i!=h){m(this,k.KB,g,i,h);}}} putIfAbsent( g, j()){if(q)CF(g);var h=zE.length;var i=zE.putIfAbsent(g,j);if(HB(this)&&h!=zE.length){m(this,k.o,'length',h,zE.length);m(this,k.TB,g,null,i);}return i;} remove( g){if(q)CF(g);var h=zE.length;var i=zE.remove(g);if(HB(this)&&h!=zE.length){m(this,k.QB,g,i,null);m(this,k.o,'length',h,zE.length);}return i;} addAll( g)=>g.forEach((h,i){this[h]=i;}); clear(){var g=zE.length;if(HB(this)&&g>0){zE.forEach((h,i){m(this,k.QB,h,i,null);});m(this,k.o,'length',g,0);}zE.clear();} forEach( g( key, value)){if(q)DF();zE.forEach(g);} toString()=>xB.Maps.mapToString(this);}class CD<EB,AB> extends xB.IterableBase<EB>{final  zE;CD(this.zE); get iterator=>new DE<EB,AB>(zE);}class DE<EB,AB> implements Iterator<EB>{final  zE;final  AF;var EF=false;DE( g):zE=g,AF=g.zE.keys.iterator; moveNext(){if(q)BB(zE,k.o,'length');return EF=AF.moveNext();} get current{var g=AF.current;if(q&&EF)zE.CF(g);return g;}}class DD<EB,AB> extends xB.IterableBase<AB>{final  zE;DD(this.zE); get iterator=>new EE<EB,AB>(zE);}class EE<EB,AB> implements Iterator<AB>{final  zE;final  AF;final  BF;var EF;EE( g):zE=g,AF=g.zE.keys.iterator,BF=g.zE.values.iterator; moveNext(){if(q)BB(zE,k.o,'length');var h=AF.moveNext();var g=BF.moveNext();if(h!=g){throw new StateError('keys and values should be the same length');}return EF=g;} get current{if(q&&EF)zE.CF(AF.current);return BF.current;}}typedef  NB( e);typedef  ED( changes);typedef  MB();typedef  FD();class pB{final oldValue;final newValue;final  changes;pB(this.oldValue,this.newValue,[this.changes]); operator==(g){return g is pB&&oldValue==g.oldValue&&newValue==g.newValue&&changes==g.changes;} get hashCode=>SD(oldValue,newValue,changes); toString(){if(changes!=null)return '#<ChangeNotification to ${newValue}: ${changes}>';return '#<ChangeNotification from ${oldValue} to ${newValue}>';}}class k{static const o=1;static const KB=2;static const TB=KB|4;static const QB=KB|8;final  type;final key;final oldValue;final newValue;k(this.type,this.key,this.oldValue,this.newValue); operator==(g){return g is k&&type==g.type&&key==g.key&&oldValue==g.oldValue&&newValue==g.newValue;} get hashCode=>TD(type,key,oldValue,newValue); toString(){var g;switch (type){case o:g='field';break;case KB:g='index';break;case TB:g='insert';break;case QB:g='remove';break;}return '#<ChangeRecord ${g} ${key} from ${oldValue} to ${newValue}>';}} GD(g, i,[ l]){if(g is v){var h=g;return EC(h,(t){i(new pB(h,h,t));});}var j=new qB(g,i,l);if(!j.FF()){return ID;}return j.GF;} EC( g, h){if(g.bB==null)g.bB=new GC();var i=g.bB.add(h);return i.remove;}FC(g){if(g is Map){var h=null;if(g is xB.SplayTreeMap){h=()=>new xB.SplayTreeMap();}else if(g is xB.LinkedHashMap){h=()=>new xB.LinkedHashMap();}return new YB.TE(g,createMap:h);}if(g is Set)return new bC.UE(g);if(g is Iterable)return new BD.SE(g);return g;}class v{var bB;var aB;final  hashCode= ++v.HD;static var HD=0;} HB( g)=>g.bB!=null&&g.bB.head!=null; get q=>ZB!=null; BB( g, h,i)=>ZB.HF(g,h,i); m( g, h,l, i, j){if((h&(k.TB|k.QB))==0){if(i==j)return;}if(UB==null){UB=[] ;UD(JD);}if(g.aB==null){g.aB=[] ;UB.add(g);}g.aB.add(new k(h,l,i,j));} ID(){}var ZB;var aC=100;var UB;var VB; JD(){var t=0;while (UB!=null||VB!=null){var i=UB;UB=null;var j=VB;VB=null;if(t++ ==aC){KD(i,j);return;}if(i!=null){for(var g in i){var GB=g.aB;g.aB=null;for(var h=g.bB.head;h!=null;h=h.next){var l=h.value;try {l(GB);}catch (XB,SC){fB(XB,SC,l,'from ${g}');}}}}if(j!=null){j.forEach((qC,TC){TC.IF();});}}} KD( h, i){var g=[] ;if(h!=null){for(var j in h){var GB=j.aB;g.add('${j} ${GB}');}}if(i!=null){for(var l in i.values){var t=l.IF();if(t!=null)g.add('${l} ${t}');}}UB=null;VB=null;var XB='exceeded notifiction limit of ${aC}, possible ' 'circular reference in observer callbacks: ${g.take(10).join(", ")}';ND(XB);}class qB{static var LD=0;final  JF= ++qB.LD;final  KF;final  LF;final  MF;final  NF=new Map();final  OF=[] ;var PF=false;var QF;qB(this.KF,this.LF,this.MF); toString()=>MF!=null?'<observer ${JF}: ${MF}>':'<observer ${JF}>'; FF(){var g=ZB;ZB=this;try {QF=KF();if(QF is Iterable&&QF is !List&&QF is !v){QF=(QF as Iterable).toList();}}catch (h,i){fB(h,i,KF,'from ${this}');QF=null;}NF.forEach(RF);NF.clear();assert(ZB==this);ZB=g;SF();return OF.length>0;} TF( g){try {LF(g);}catch (h,i){fB(h,i,LF,'from ${this}');}} SF(){var g=QF;if(g is !v)return;OF.add(EC(g,(h){TF(new pB(g,g,h));}));} HF( j, l,g){var i=NF.putIfAbsent(j,()=>new Map());try {var h=i[g];if(h==null)h=0;i[g]=h|l;}catch (t,GB){fB(t,GB,g,'hashCode or operator == from ${this}');}} RF( i, j){OF.add(EC(i,(l){if(PF)return;for(var g in l){var h=j[g.key];if(h!=null&&(h&g.type)!=0){PF=true;if(VB==null){VB=new xB.SplayTreeMap();}VB[JF]=this;return;}}}));} GF(){for(var g in OF){g();}PF=false;} IF(){if(!PF)return null;var g=QF;GF();FF();try {if(g==QF)return null;}catch (i,j){fB(i,j,g,'operator == from ${this}');return null;}var h=new pB(g,QF);TF(h);return h;}}typedef  MD( message);var ND=(g)=>print(g);typedef  OD(error,stackTrace,obj, message);var fB=PD; PD(g,h,i, j){print('web_ui.observe: unhandled error calling ${i} ${j}.\n' 'error:\n${g}\n\nstack trace:\n${h}');}class bC<LB> extends XD with v implements Set<LB>{final  UF;final  VF;bC({ createMap}):UF=createMap!=null?createMap():new Map<LB,Object>(),VF=createMap;factory bC.UE( g,{ createMap}){return new bC<LB>(createMap:createMap)..addAll(g);} contains( g){if(q)BB(this,k.KB,g);return UF.containsKey(g);} add( g){var h=UF.length;UF[g]=const Object();if(h!=UF.length){m(this,k.o,'length',h,UF.length);m(this,k.TB,g,null,g);}} remove( g){if(q)BB(this,k.KB,g);var h=UF.length;UF.remove(g);if(h!=UF.length){if(HB(this)){m(this,k.QB,g,g,null);m(this,k.o,'length',h,UF.length);}return true;}return false;} clear(){if(HB(this)){for(var g in UF.keys){m(this,k.QB,g,g,null);}m(this,k.o,'length',UF.length,0);}UF.clear();} get length{if(q)BB(this,k.o,'length');return UF.length;} get isEmpty=>length==0; get iterator=>new FE<LB>(this); addAll( g)=>g.forEach(add); toString(){if(q){for(LB g in UF.keys){BB(this,k.KB,g);}}return UF.keys.toSet().toString();}}class FE<LB> implements Iterator<LB>{final  WF;final  XF;var YF=false;FE( g):WF=g,XF=g.UF.keys.iterator; moveNext(){WF.length;return YF=XF.moveNext();} get current{var g=XF.current;if(q&&YF)BB(WF,k.KB,g);return g;}}class QD{}class RD{}class IB<JB>{var ZF;var aF;var bF;var cF;IB.VE( g,this.bF):cF=g{if(bF!=null)bF.dF++ ;} get next=>aF; get value=>cF;set value( g)=>cF=g; eF( g, h){aF=h;ZF=g;if(g!=null)g.aF=this;if(h!=null)h.ZF=this;return this;} append( g)=>new IB<JB>.VE(g,bF).eF(this,aF); remove(){if(bF==null)return;bF.dF-- ;if(ZF!=null){ZF.aF=aF;}else{bF.fF=aF;}if(aF!=null){aF.ZF=ZF;}else{bF.gF=ZF;}aF=null;ZF=null;bF=null;}}class GC<JB> extends xB.IterableBase<JB>{var fF;var gF; get length=>dF;var dF=0;GC(){} get head=>fF; add( h){var g=new IB<JB>.VE(h,this);if(gF==null)return fF=gF=g;return gF=g.eF(gF,null);} addLast( g)=>add(g); addAll( g)=>g.forEach(add); get iterator=>new GE<JB>(this);}class GE<JB> implements Iterator<JB>{var hF;var bF;var iF;var jF=-1;GE(this.bF){hF=new List<IB>(bF.length);var h=0;var g=bF.head;while (g!=null){hF[h++ ]=g;g=g.next;}} get current=>iF; moveNext(){do{jF++ ;}while(jF<hF.length&&hF[jF].bF!=bF);if(jF<hF.length){iF=hF[jF].value;return true;}else{iF=null;return false;}}}gB(g,h)=>g.hashCode*31+h.hashCode;SD(g,h,i)=>gB(gB(g,h),i);TD(g,h,i,j)=>gB(gB(g,h),gB(i,j)); UD( h()){var g=new QE.ReceivePort();g.receive((i,j){g.close();h();});g.toSendPort().send(null);}class cC{static  VD( t, g, GB, i, l){if(g==null)g=0;if(i==null)i=0;if(g<i){for(int h=g+l-1,j=i+l-1;h>=g;h-- ,j-- ){GB[j]=t[h];}}else{for(int h=g,j=i;h<g+l;h++ ,j++ ){GB[j]=t[h];}}}static  WD( j, g, h){if(h<0){throw new ArgumentError("negative length ${h}");}if(g<0){var i="${g} must be greater than or equal to 0";throw new RangeError(i);}if(g+h>j.length){var i="${g} + ${h} must be in the range [0..${j.length})";throw new RangeError(i);}}}abstract class XD extends xB.IterableBase<dynamic>{}abstract class YD extends xB.ListMixin<dynamic>{}var HC=new HE();class HE implements CB.NodeTreeSanitizer{ sanitizeTree( g){}} ZD(h, g,[ i]){if(h is CB.Node){g.replaceWith(h);return h;}var j=h is QD;if(i==null){i=h.toString();}if(!j&&g is CB.Text){g.text=i;}else{var l=g;g=!j?new CB.Text(i):new CB.Element.html(i,treeSanitizer:HC);l.replaceWith(g);}return g;} aD(g){if(g is RD)return g.toString();g=g.toString();return cD(g)?g:'#';}const bD=const["http","https","ftp","mailto"]; cD( h){var g=Uri.parse(h).scheme;if(g=='')return true;return bD.contains(g.toLowerCase())||"MAILTO"==g.toUpperCase();}abstract class rB{ WB(){} insert(); remove();}class IE extends rB{final  lC;var kF;final  listener;IE(this.lC,this.listener); insert(){kF=lC.listen(listener);} remove(){kF.cancel();kF=null;}}abstract class dC extends rB{final exp;final  isFinal;final  OC;var DB;dC(this.exp,this.isFinal):OC=JC&&sB!=null?sB():null; insert(){if(isFinal){PC();}else if(DB!=null){throw new StateError('binding already attached');}else{DB=QC();}} remove(){if(!isFinal){DB();DB=null;}} PC(); QC();}class JE extends dC{final  action;JE(g,this.action, h):super(g,h); PC()=>action(new pB(null,exp())); QC()=>iB(exp,action,'generic-binding',OC);}class KE extends dC{final  pC;final  nC;KE( g,this.pC,this.nC, h):super(g,h); lF(g){pC(nC?aD(g):g);} PC()=>lF(exp()); QC()=>iB(exp,(g)=>lF(g.newValue),'dom-property-binding',OC);}class IC extends rB{final  nB;final  children=[] ;final  nodes=[] ;IC(this.nB); listen( g, h){children.add(new IE(g,(i){h(i);iD();}));} NC( h,i){var g=new CB.Text('');children.add(new JE(()=>'${h()}',(j){g=ZD(h(),g,j.newValue);},i));return g;} sD(g,h,i,[j=false]){children.add(new KE(g,h,j,i));} uB( g,h,i){children.add(new eD(g,h,i));} loop( g,h,i){children.add(new LE(g,h,i));} oC( g,h,i){children.add(new ME(g,h,i));} add( g)=>nodes.add(g); addAll( g)=>nodes.addAll(g); WB(){for(var g=0,h=children.length;g<h;g++ ){children[g].WB();}} insert(){for(var g=0,h=children.length;g<h;g++ ){children[g].insert();}} remove(){for(var g=children.length-1;g>=0;g-- ){children[g].remove();}children.clear();}}abstract class eC extends IC{final exp;var DB;eC( g,this.exp):super(g); WB(){} insert(){super.WB();if(nodes.length>0){var h=nB.parentNode;var i=nB.nextNode;for(var g=0,j=nodes.length;g<j;g++ ){h.insertBefore(nodes[g],i);}}super.insert();} remove(){super.remove();for(var g=nodes.length-1;g>=0;g-- ){nodes[g].remove();}nodes.clear();}}typedef  dD( template);class eD extends eC{var vB=false;final  kC;eD( g,h,this.kC):super(g,h); insert(){DB=iB(exp,(g){if(!vB&&g.newValue){kC(this);super.insert();vB=true;}else if(vB&&!g.newValue){super.remove();vB=false;}},'conditional-binding');} remove(){super.remove();DB();DB=null;}}typedef  fC( list, index, template);class LE extends eC{final  mB;LE( g,h,this.mB):super(g,h); insert(){DB=iB(exp,(i){super.remove();var h=i.newValue;for(int g=0;g<h.length;g++ ){mB(h,g,this);}super.insert();},'loop-binding');} remove(){super.remove();DB();DB=null;}}class ME extends IC{final  mB;final exp;var DB;ME( g,this.exp,this.mB):super(g); WB(){} insert(){DB=iB(exp,(i){mF();var h=i.newValue;for(int g=0;g<h.length;g++ ){mB(h,g,this);}super.WB();nB.nodes.addAll(nodes);super.insert();},'loop-attribute-binding');} mF(){super.remove();nB.nodes.clear();nodes.clear();} remove(){mF();DB();DB=null;}}var gC=false;var JC=false;var sB=(){try {throw "";}catch (h,g){return g.toString();}};final  hB=new SB('watcher'); fD(g, t,[ j, GB]){if(gC)return GD(g,t);if(t==null)return (){};if(jB==null)jB=new GC<kB>();j=j==null?'<unnamed>':j;var i;var h=FB.mD;if(g is jC){i=(g as jC).nF;}else if(g is Function){i=g;try {var l=g();if(l is List){h=FB.lB;}else if(l is Iterable){h=FB.lB;i=()=>g().toList();}else if((l is xB.LinkedHashMap)||(l is xB.SplayTreeMap)){h=FB.MC;}else if(l is Map){h=FB.LC;}}catch (XB,SC){hB.RC('evaluating ${j} watcher threw error (${XB}, ${SC})');}}else if(g is List){i=()=>g;h=FB.lB;}else if(g is Iterable){i=()=>g.toList();h=FB.lB;}else if((g is xB.LinkedHashMap)||(g is xB.SplayTreeMap)){i=()=>g;h=FB.MC;}else if(g is Map){i=()=>g;h=FB.LC;}if(JC&&GB==null&&sB!=null){GB=sB();}var TC=gD(h,i,t,j,GB);var qC=jB.add(TC);return qC.remove;} gD( l, g, h, i, j){switch (l){case FB.lB:return new NE(g,h,i,j);case FB.MC:return new PE(g,h,i,j);case FB.LC:return new OE(g,h,i,j);default:return new kB(g,h,i,j);}} iB(h, i,[ j, l]){var t=fD(h,i,j,l);var g=h;if(g is Function){g=g();}if(g is Iterable&&g is !List){g=g.toList();}i(new pB(null,g));return t;}var jB;class kB{final  debugName;var location;final  oF;static var hD=0;final  nF;final  pF;var qF;kB(this.nF,this.pF,this.debugName,this.location):oF=hD++ {qF=nF();} toString()=>'${debugName} (id: #${oF})'; pD(){var g=rF();if(sF(g)){var h=qF;tF(g);pF(new pB(h,g));return true;}return false;} sF(g)=>qF!=g; tF(g){if(JC){if(location!=null){hB.info('watcher updated: ${this}, defined at:\n${location}');location=null;}else{hB.info('watcher updated: ${this}');}}qF=g;}rF(){try {return nF();}catch (g,h){hB.RC('${this} watcher threw an exception: ${g}, ${h}');}return qF;}}final  hC=10; iD(){if(jB==null)return;var g;var h=0;do{g=false;for(var i in jB){if(i.pD()){g=true;}}}while(g&& ++h<hC);if(h==hC){hB.RC('Possible loop in watchers propagation, stopped dispatch.');}}typedef  iC<jD>();typedef  kD<jD>( value);class jC<jD>{}class NE<jD> extends kB{NE(g, h, i, j):super(g,h,i,j){tF(rF());} sF( g){return KC(qF,g);} tF(g){qF=new List<jD>.from(g);}}class OE<tB,lD> extends kB{OE(g, h, i, j):super(g,h,i,j){tF(rF());} sF( g){var i=qF.keys;if(i.length!=g.keys.length)return true;var j=i.iterator;while (j.moveNext()){var h=j.current;if(!g.containsKey(h))return true;if(qF[h]!=g[h])return true;}return false;} tF(g){qF=new Map<tB,lD>.from(g);}}class PE<tB,lD> extends kB{PE(g, h, i, j):super(g,h,i,j){tF(rF());} sF( g){return KC(g.keys,qF.keys)||KC(g.values,qF.values);} tF(g){qF=new xB.LinkedHashMap.from(g);}} KC( i, j){var h=i.iterator;var g=j.iterator;while (h.moveNext()){if(!g.moveNext())return true;if(h.current!=g.current)return true;}return g.moveNext();}class FB{final uF;const FB.WE(this.uF);toString()=>'Enum.${uF}';static const lB=const FB.WE('LIST');static const LC=const FB.WE('HASH_MAP');static const MC=const FB.WE('ORDERED_MAP');static const mD=const FB.WE('OTHER');}var nD=CB.document.body;
//# sourceMappingURL=hangman.html_bootstrap.dart.map
//@ sourceMappingURL=hangman.html_bootstrap.dart.map
