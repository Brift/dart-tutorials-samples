import "dart:html" as BB;import "dart:collection" as lB;import "dart:async" as tC;import "dart:isolate" as JD;class uC{static const  vC="Chrome";final  nC;final  minimumVersion;const uC(this.nC,[this.minimumVersion]);}class wC{const wC();}class xC{final  name;const xC(this.name);}class yC{const yC();}class zC{const zC();}final WB=new m();var XB; get AC{if(NC){OC(WB,DB.ZB,'currentTime');}return XB;}set AC( g){if(MC(WB)){PC(WB,DB.ZB,'currentTime',XB,g);}XB=g;} BC(){var g=new Duration(seconds:1);new tC.Timer.periodic(g,mB);mB(null);} mB( OD){var g=new DateTime.now();AC=CC(g.hour,g.minute,g.second);} CC( g, h, i){if(g>12){g=g-12;}var j=(h<=9)?'0${h}':'${h}';var k=(i<=9)?'0${i}':'${i}';return '${g}:${j}:${k}';} DC(){var PD=mC;var QD;var RD=new DD(PD);QD=PD.nodes[3];var SD=RD.oC(()=>AC,false);QD.nodes.addAll([new BB.Text('\n      The current time is: '),SD,new BB.Text('\n    ')]);RD.iB();RD.insert();}main(){sB=true;BC();DC();}var nB=false;var EC=l.oB;class EB{final  name; get vB=>(parent==null||parent.name=='')?name:'${parent.vB}.${name}';final  parent;var TD;var children;var UD;var VD;factory EB( g){if(g.startsWith('.')){throw new ArgumentError("name shouldn't start with a '.'");}if(KB==null)KB=<String,EB>{};if(KB.containsKey(g))return KB[g];var h=g.lastIndexOf('.');var i=null;var j;if(h==-1){if(g!='')i=new EB('');j=g;}else{i=new EB(g.substring(0,h));j=g.substring(h+1);}final k=new EB.KD(j,i);KB[g]=k;return k;}EB.KD(this.name,this.parent):children=new Map<String,EB>(){if(parent!=null)parent.children[name]=this;} get UB{if(nB){if(TD!=null)return TD;if(parent!=null)return parent.UB;}return EC;} pC( g)=>(g>=UB); log( h, j,[k]){if(pC(h)){var i=new YB(h,j,vB,k);if(nB){var g=this;while (g!=null){g.WD(i);g=g.parent;}}else{FC.WD(i);}}} info( g,[h])=>log(l.oB,g,h); yB( g,[h])=>log(l.GC,g,h); WD( g){if(UD!=null){UD.add(g);}}static  get FC=>new EB('');static var KB;}class l implements Comparable<l>{final  name;final  value;const l(this.name,this.value);static const  oB=const l('INFO',800);static const  GC=const l('WARNING',900); operator==( g)=>g!=null&&value==g.value; operator<( g)=>value<g.value; operator<=( g)=>value<=g.value; operator>( g)=>value>g.value; operator>=( g)=>value>=g.value; compareTo( g)=>value-g.value; get hashCode=>value; toString()=>name;}class YB{final  UB;final  message;final  qC;final  time;final  sC;static var HC=0;var exception;YB(this.UB,this.message,this.qC,[this.exception]):time=new DateTime.now(),sC=YB.HC++ ;}typedef  v( e);typedef  IC( changes);typedef  CB();typedef  JC();class QB{final oldValue;final newValue;final  changes;QB(this.oldValue,this.newValue,[this.changes]); operator==(g){return g is QB&&oldValue==g.oldValue&&newValue==g.newValue&&changes==g.changes;} get hashCode=>ZC(oldValue,newValue,changes); toString(){if(changes!=null)return '#<ChangeNotification to ${newValue}: ${changes}>';return '#<ChangeNotification from ${oldValue} to ${newValue}>';}}class DB{static const ZB=1;static const aB=2;static const pB=aB|4;static const qB=aB|8;final  type;final key;final oldValue;final newValue;DB(this.type,this.key,this.oldValue,this.newValue); operator==(g){return g is DB&&type==g.type&&key==g.key&&oldValue==g.oldValue&&newValue==g.newValue;} get hashCode=>aC(type,key,oldValue,newValue); toString(){var g;switch (type){case ZB:g='field';break;case aB:g='index';break;case pB:g='insert';break;case qB:g='remove';break;}return '#<ChangeRecord ${g} ${key} from ${oldValue} to ${newValue}>';}} KC(g, i,[ k]){if(g is m){var h=g;return bB(h,(q){i(new QB(h,h,q));});}var j=new RB(g,i,k);if(!j.XD()){return QC;}return j.YD;} bB( g, h){if(g.JB==null)g.JB=new cB();var i=g.JB.add(h);return i.remove;}class m{var JB;var IB;final  hashCode= ++m.LC;static var LC=0;} MC( g)=>g.JB!=null&&g.JB.head!=null; get NC=>HB!=null; OC( g, h,i)=>HB.ZD(g,h,i); PC( g, h,k, i, j){if((h&(DB.pB|DB.qB))==0){if(i==j)return;}if(FB==null){FB=[] ;bC(RC);}if(g.IB==null){g.IB=[] ;FB.add(g);}g.IB.add(new DB(h,k,i,j));} QC(){}var HB;var rB=100;var FB;var GB; RC(){var q=0;while (FB!=null||GB!=null){var i=FB;FB=null;var j=GB;GB=null;if(q++ ==rB){SC(i,j);return;}if(i!=null){for(var g in i){var AB=g.IB;g.IB=null;for(var h=g.JB.head;h!=null;h=h.next){var k=h.value;try {k(AB);}catch (PB,jB){LB(PB,jB,k,'from ${g}');}}}}if(j!=null){j.forEach((zB,kB){kB.aD();});}}} SC( h, i){var g=[] ;if(h!=null){for(var j in h){var AB=j.IB;g.add('${j} ${AB}');}}if(i!=null){for(var k in i.values){var q=k.aD();if(q!=null)g.add('${k} ${q}');}}FB=null;GB=null;var PB='exceeded notifiction limit of ${rB}, possible ' 'circular reference in observer callbacks: ${g.take(10).join(", ")}';VC(PB);}class RB{static var TC=0;final  bD= ++RB.TC;final  cD;final  dD;final  eD;final  fD=new Map();final  gD=[] ;var hD=false;var iD;RB(this.cD,this.dD,this.eD); toString()=>eD!=null?'<observer ${bD}: ${eD}>':'<observer ${bD}>'; XD(){var g=HB;HB=this;try {iD=cD();if(iD is Iterable&&iD is !List&&iD is !m){iD=(iD as Iterable).toList();}}catch (h,i){LB(h,i,cD,'from ${this}');iD=null;}fD.forEach(jD);fD.clear();assert(HB==this);HB=g;kD();return gD.length>0;} lD( g){try {dD(g);}catch (h,i){LB(h,i,dD,'from ${this}');}} kD(){var g=iD;if(g is !m)return;gD.add(bB(g,(h){lD(new QB(g,g,h));}));} ZD( j, k,g){var i=fD.putIfAbsent(j,()=>new Map());try {var h=i[g];if(h==null)h=0;i[g]=h|k;}catch (q,AB){LB(q,AB,g,'hashCode or operator == from ${this}');}} jD( i, j){gD.add(bB(i,(k){if(hD)return;for(var g in k){var h=j[g.key];if(h!=null&&(h&g.type)!=0){hD=true;if(GB==null){GB=new lB.SplayTreeMap();}GB[bD]=this;return;}}}));} YD(){for(var g in gD){g();}hD=false;} aD(){if(!hD)return null;var g=iD;YD();XD();try {if(g==iD)return null;}catch (i,j){LB(i,j,g,'operator == from ${this}');return null;}var h=new QB(g,iD);lD(h);return h;}}typedef  UC( message);var VC=(g)=>print(g);typedef  WC(error,stackTrace,obj, message);var LB=XC; XC(g,h,i, j){print('web_ui.observe: unhandled error calling ${i} ${j}.\n' 'error:\n${g}\n\nstack trace:\n${h}');}class YC{}class t<u>{var mD;var nD;var oD;var pD;t.LD( g,this.oD):pD=g{if(oD!=null)oD.qD++ ;} get next=>nD; get value=>pD;set value( g)=>pD=g; rD( g, h){nD=h;mD=g;if(g!=null)g.nD=this;if(h!=null)h.mD=this;return this;} append( g)=>new t<u>.LD(g,oD).rD(this,nD); remove(){if(oD==null)return;oD.qD-- ;if(mD!=null){mD.nD=nD;}else{oD.sD=nD;}if(nD!=null){nD.mD=mD;}else{oD.tD=mD;}nD=null;mD=null;oD=null;}}class cB<u> extends lB.IterableBase<u>{var sD;var tD; get length=>qD;var qD=0;cB(){} get head=>sD; add( h){var g=new t<u>.LD(h,this);if(tD==null)return sD=tD=g;return tD=g.rD(tD,null);} addLast( g)=>add(g); addAll( g)=>g.forEach(add); get iterator=>new AD<u>(this);}class AD<u> implements Iterator<u>{var uD;var oD;var vD;var wD=-1;AD(this.oD){uD=new List<t>(oD.length);var h=0;var g=oD.head;while (g!=null){uD[h++ ]=g;g=g.next;}} get current=>vD; moveNext(){do{wD++ ;}while(wD<uD.length&&uD[wD].oD!=oD);if(wD<uD.length){vD=uD[wD].value;return true;}else{vD=null;return false;}}}MB(g,h)=>g.hashCode*31+h.hashCode;ZC(g,h,i)=>MB(MB(g,h),i);aC(g,h,i,j)=>MB(MB(g,h),MB(i,j)); bC( h()){var g=new JD.ReceivePort();g.receive((i,j){g.close();h();});g.toSendPort().send(null);}var cC=new BD();class BD implements BB.NodeTreeSanitizer{ sanitizeTree( g){}} dC(h, g,[ i]){if(h is BB.Node){g.replaceWith(h);return h;}var j=h is YC;if(i==null){i=h.toString();}if(!j&&g is BB.Text){g.text=i;}else{var k=g;g=!j?new BB.Text(i):new BB.Element.html(i,treeSanitizer:cC);k.replaceWith(g);}return g;}abstract class dB{ iB(){} insert(); remove();}abstract class eC extends dB{final exp;final  isFinal;final  uB;var VB;eC(this.exp,this.isFinal):uB=eB&&SB!=null?SB():null; insert(){if(isFinal){wB();}else if(VB!=null){throw new StateError('binding already attached');}else{VB=xB();}} remove(){if(!isFinal){VB();VB=null;}} wB(); xB();}class CD extends eC{final  action;CD(g,this.action, h):super(g,h); wB()=>action(new QB(null,exp())); xB()=>hC(exp,action,'generic-binding',uB);}class DD extends dB{final  rC;final  children=[] ;final  nodes=[] ;DD(this.rC); oC( h,i){var g=new BB.Text('');children.add(new CD(()=>'${h()}',(j){g=dC(h(),g,j.newValue);},i));return g;} add( g)=>nodes.add(g); addAll( g)=>nodes.addAll(g); iB(){for(var g=0,h=children.length;g<h;g++ ){children[g].iB();}} insert(){for(var g=0,h=children.length;g<h;g++ ){children[g].insert();}} remove(){for(var g=children.length-1;g>=0;g-- ){children[g].remove();}children.clear();}}var sB=false;var eB=false;var SB=(){try {throw "";}catch (h,g){return g.toString();}};final  TB=new EB('watcher'); fC(g, q,[ j, AB]){if(sB)return KC(g,q);if(q==null)return (){};if(fB==null)fB=new cB<NB>();j=j==null?'<unnamed>':j;var i;var h=o.lC;if(g is tB){i=(g as tB).xD;}else if(g is Function){i=g;try {var k=g();if(k is List){h=o.OB;}else if(k is Iterable){h=o.OB;i=()=>g().toList();}else if((k is lB.LinkedHashMap)||(k is lB.SplayTreeMap)){h=o.hB;}else if(k is Map){h=o.gB;}}catch (PB,jB){TB.yB('evaluating ${j} watcher threw error (${PB}, ${jB})');}}else if(g is List){i=()=>g;h=o.OB;}else if(g is Iterable){i=()=>g.toList();h=o.OB;}else if((g is lB.LinkedHashMap)||(g is lB.SplayTreeMap)){i=()=>g;h=o.hB;}else if(g is Map){i=()=>g;h=o.gB;}if(eB&&AB==null&&SB!=null){AB=SB();}var kB=gC(h,i,q,j,AB);var zB=fB.add(kB);return zB.remove;} gC( k, g, h, i, j){switch (k){case o.OB:return new ED(g,h,i,j);case o.hB:return new ID(g,h,i,j);case o.gB:return new FD(g,h,i,j);default:return new NB(g,h,i,j);}} hC(h, i,[ j, k]){var q=fC(h,i,j,k);var g=h;if(g is Function){g=g();}if(g is Iterable&&g is !List){g=g.toList();}i(new QB(null,g));return q;}var fB;class NB{final  debugName;var location;final  yD;static var iC=0;final  xD;final  zD;var AE;NB(this.xD,this.zD,this.debugName,this.location):yD=iC++ {AE=xD();} toString()=>'${debugName} (id: #${yD})'; BE(g){if(eB){if(location!=null){TB.info('watcher updated: ${this}, defined at:\n${location}');location=null;}else{TB.info('watcher updated: ${this}');}}AE=g;}CE(){try {return xD();}catch (g,h){TB.yB('${this} watcher threw an exception: ${g}, ${h}');}return AE;}}typedef  jC<kC>();class tB<kC>{}class ED<kC> extends NB{ED(g, h, i, j):super(g,h,i,j){BE(CE());} BE(g){AE=new List<kC>.from(g);}}class FD<GD,HD> extends NB{FD(g, h, i, j):super(g,h,i,j){BE(CE());} BE(g){AE=new Map<GD,HD>.from(g);}}class ID<GD,HD> extends NB{ID(g, h, i, j):super(g,h,i,j){BE(CE());} BE(g){AE=new lB.LinkedHashMap.from(g);}}class o{final DE;const o.MD(this.DE);toString()=>'Enum.${DE}';static const OB=const o.MD('LIST');static const gB=const o.MD('HASH_MAP');static const hB=const o.MD('ORDERED_MAP');static const lC=const o.MD('OTHER');}var mC=BB.document.body;
//# sourceMappingURL=littleben.html_bootstrap.dart.map
//@ sourceMappingURL=littleben.html_bootstrap.dart.map
